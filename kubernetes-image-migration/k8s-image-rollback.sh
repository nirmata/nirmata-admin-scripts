#!/bin/bash

# Kubernetes Image Migration Rollback Script
# Rolls back container images to their original state using migration audit CSV files

set -euo pipefail

# Default values
CSV_FILE=""
NAMESPACE=""
DRY_RUN=false
INTERACTIVE=false
VERBOSE=false
ROLLBACK_CSV=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1"
    fi
}

# Help function
show_help() {
    cat << EOF
Kubernetes Image Migration Rollback Tool

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -f, --csv-file FILE            Migration CSV file to use for rollback (required)
    -n, --namespace NAMESPACE      Target namespace (optional, will use CSV data if not specified)
    --dry-run                      Perform a dry run without making changes
    -i, --interactive              Ask for confirmation before each rollback
    --rollback-csv FILE            Output rollback audit CSV file
    -v, --verbose                  Enable verbose logging
    -h, --help                     Show this help message

EXAMPLES:
    # Dry run rollback using migration CSV
    $0 --dry-run \\
       --csv-file production-migration-executed.csv \\
       --rollback-csv production-rollback-audit.csv

    # Interactive rollback for specific namespace
    $0 --interactive \\
       --csv-file production-migration-executed.csv \\
       --namespace production \\
       --rollback-csv production-rollback-executed.csv

    # Full rollback with audit trail
    $0 --csv-file staging-migration-executed.csv \\
       --rollback-csv staging-rollback-executed.csv

NOTES:
    - The CSV file should be generated by the migration script
    - Rollback will restore images to their original (source) state
    - ImagePullSecrets added during migration will NOT be removed for safety
    - Always run with --dry-run first to validate the rollback plan

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--csv-file)
                CSV_FILE="$2"
                shift 2
                ;;
            -n|--namespace)
                NAMESPACE="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -i|--interactive)
                INTERACTIVE=true
                shift
                ;;
            --rollback-csv)
                ROLLBACK_CSV="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$CSV_FILE" ]]; then
        log_error "CSV file is required. Use -f or --csv-file"
        exit 1
    fi

    if [[ ! -f "$CSV_FILE" ]]; then
        log_error "CSV file does not exist: $CSV_FILE"
        exit 1
    fi
}

# Check if kubectl is available
check_kubectl() {
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed or not in PATH"
        exit 1
    fi

    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
}

# Parse CSV file and extract rollback information
parse_csv_file() {
    local csv_file=$1
    local rollback_file="/tmp/rollback_plan_$$.txt"
    
    # Skip header and process each line
    tail -n +2 "$csv_file" | while IFS=',' read -r timestamp namespace resource_type resource_name source_image dest_image source_registry dest_registry image_pull_secret migration_status; do
        # Clean up quoted fields
        source_image=$(echo "$source_image" | sed 's/^"//;s/"$//')
        dest_image=$(echo "$dest_image" | sed 's/^"//;s/"$//')
        
        # If namespace filter is specified, only include matching namespaces
        if [[ -n "$NAMESPACE" && "$namespace" != "$NAMESPACE" ]]; then
            continue
        fi
        
        # Create rollback entry (swap source and destination)
        echo "$namespace|$resource_type|$resource_name|$dest_image|$source_image"
    done > "$rollback_file"
    
    echo "$rollback_file"
}

# Display rollback plan
display_rollback_plan() {
    local rollback_file=$1
    
    if [[ ! -s "$rollback_file" ]]; then
        log_warning "No rollback entries found in CSV file."
        return 1
    fi
    
    echo
    echo "================================================================================"
    echo "                              ROLLBACK PLAN"
    echo "================================================================================"
    echo "CSV Source File: $CSV_FILE"
    if [[ -n "$NAMESPACE" ]]; then
        echo "Target Namespace: $NAMESPACE"
    else
        echo "Target Namespace: All namespaces from CSV"
    fi
    echo "================================================================================"
    
    local current_namespace=""
    local count=0
    
    while IFS='|' read -r namespace resource_type resource_name current_image original_image; do
        if [[ "$namespace" != "$current_namespace" ]]; then
            echo
            echo "Namespace: $namespace"
            echo "----------------------------------------"
            current_namespace="$namespace"
        fi
        
        echo "  Resource: $resource_type/$resource_name"
        echo "    CURRENT: $current_image"
        echo "    ROLLBACK TO: $original_image"
        echo
        ((count++))
    done < "$rollback_file"
    
    echo "================================================================================"
    echo "Total images to rollback: $count"
    echo "================================================================================"
    
    return 0
}

# Create rollback audit CSV
create_rollback_csv() {
    local rollback_file=$1
    local output_file=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Create CSV header
    cat > "$output_file" << EOF
Timestamp,Namespace,Resource Type,Resource Name,Current Image,Rollback Image,Action,Status
EOF
    
    # Add data rows
    while IFS='|' read -r namespace resource_type resource_name current_image original_image; do
        echo "$timestamp,$namespace,$resource_type,$resource_name,\"$current_image\",\"$original_image\",Rollback,Planned" >> "$output_file"
    done < "$rollback_file"
}

# Update container image in resource (rollback)
rollback_container_image() {
    local namespace=$1
    local resource_type=$2
    local resource_name=$3
    local current_image=$4
    local original_image=$5
    
    log_verbose "Rolling back image in $resource_type/$resource_name"
    
    # Get current resource JSON
    local temp_file="/tmp/k8s_rollback_$$.json"
    if ! kubectl get "$resource_type" "$resource_name" -n "$namespace" -o json > "$temp_file" 2>/dev/null; then
        log_error "Resource $resource_type/$resource_name not found in namespace $namespace"
        rm -f "$temp_file"
        return 1
    fi
    
    # Create patch based on resource type
    local patch_file="/tmp/k8s_rollback_patch_$$.json"
    
    case "$resource_type" in
        deployment|statefulset|daemonset)
            # Update containers and initContainers
            jq --arg current "$current_image" --arg original "$original_image" '
                (.spec.template.spec.containers[]? | select(.image == $current) | .image) = $original |
                (.spec.template.spec.initContainers[]? | select(.image == $current) | .image) = $original
            ' "$temp_file" > "$patch_file"
            ;;
        cronjob)
            jq --arg current "$current_image" --arg original "$original_image" '
                (.spec.jobTemplate.spec.template.spec.containers[]? | select(.image == $current) | .image) = $original |
                (.spec.jobTemplate.spec.template.spec.initContainers[]? | select(.image == $current) | .image) = $original
            ' "$temp_file" > "$patch_file"
            ;;
        pod|job)
            jq --arg current "$current_image" --arg original "$original_image" '
                (.spec.containers[]? | select(.image == $current) | .image) = $original |
                (.spec.initContainers[]? | select(.image == $current) | .image) = $original
            ' "$temp_file" > "$patch_file"
            ;;
    esac
    
    # Apply the patch
    local kubectl_cmd="kubectl replace -f $patch_file"
    if [[ "$DRY_RUN" == "true" ]]; then
        kubectl_cmd="$kubectl_cmd --dry-run=client"
    fi
    
    if eval "$kubectl_cmd" &> /dev/null; then
        log_success "Image rolled back successfully"
        rm -f "$temp_file" "$patch_file"
        return 0
    else
        log_error "Failed to rollback image"
        rm -f "$temp_file" "$patch_file"
        return 1
    fi
}

# Execute rollback
execute_rollback() {
    local rollback_file=$1
    
    if [[ ! -s "$rollback_file" ]]; then
        log_warning "No images to rollback."
        return 0
    fi
    
    echo
    echo "================================================================================"
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "                    EXECUTING ROLLBACK PLAN (DRY-RUN)"
    else
        echo "                       EXECUTING ROLLBACK PLAN"
    fi
    echo "================================================================================"
    
    local success_count=0
    local total_count=0
    
    while IFS='|' read -r namespace resource_type resource_name current_image original_image; do
        ((total_count++))
        
        if [[ "$INTERACTIVE" == "true" ]]; then
            echo
            read -p "Rollback $resource_type/$resource_name in $namespace? (y/n/q): " -n 1 -r
            echo
            case $REPLY in
                [Yy])
                    ;;
                [Qq])
                    log_info "Rollback cancelled by user."
                    break
                    ;;
                *)
                    log_info "Skipping..."
                    continue
                    ;;
            esac
        fi
        
        local prefix=""
        if [[ "$DRY_RUN" == "true" ]]; then
            prefix="[DRY-RUN] "
        fi
        
        log_info "${prefix}Rolling back $resource_type/$resource_name in namespace $namespace"
        log_info "  FROM: $current_image"
        log_info "  TO:   $original_image"
        
        if rollback_container_image "$namespace" "$resource_type" "$resource_name" "$current_image" "$original_image"; then
            ((success_count++))
        fi
        
    done < "$rollback_file"
    
    echo
    echo "================================================================================"
    local plan_or_execution="plan"
    if [[ "$DRY_RUN" != "true" ]]; then
        plan_or_execution="execution"
    fi
    echo "Rollback $plan_or_execution completed: $success_count/$total_count successful"
    echo "================================================================================"
    
    if [[ $success_count -eq $total_count ]]; then
        return 0
    else
        return 1
    fi
}

# Validate CSV file format
validate_csv_file() {
    local csv_file=$1
    
    # Check if file has proper header
    local header=$(head -n 1 "$csv_file")
    if [[ "$header" != "Timestamp,Namespace,Resource Type,Resource Name,Source Image,Destination Image,Source Registry,Destination Registry,Image Pull Secret,Migration Status" ]]; then
        log_error "Invalid CSV file format. Expected migration audit CSV file."
        log_error "Header should be: Timestamp,Namespace,Resource Type,Resource Name,Source Image,Destination Image,Source Registry,Destination Registry,Image Pull Secret,Migration Status"
        log_error "Got: $header"
        return 1
    fi
    
    # Check if file has data
    local line_count=$(wc -l < "$csv_file")
    if [[ $line_count -lt 2 ]]; then
        log_error "CSV file appears to be empty (no data rows found)"
        return 1
    fi
    
    log_verbose "CSV file validation passed: $line_count total lines"
    return 0
}

# Main function
main() {
    parse_args "$@"
    
    log_info "Kubernetes Image Migration Rollback Tool"
    log_info "CSV Source File: $CSV_FILE"
    if [[ -n "$NAMESPACE" ]]; then
        log_info "Target Namespace: $NAMESPACE"
    else
        log_info "Target Namespace: All namespaces from CSV"
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Mode: DRY-RUN"
    fi
    
    # Check prerequisites
    check_kubectl
    
    # Check if jq is available for JSON processing
    if ! command -v jq &> /dev/null; then
        log_error "jq is required but not installed. Please install jq."
        exit 1
    fi
    
    # Validate CSV file
    if ! validate_csv_file "$CSV_FILE"; then
        exit 1
    fi
    
    # Parse CSV file and create rollback plan
    local rollback_file
    rollback_file=$(parse_csv_file "$CSV_FILE")
    
    # Display rollback plan
    if ! display_rollback_plan "$rollback_file"; then
        rm -f "$rollback_file"
        exit 0
    fi
    
    # Save rollback plan to CSV if requested
    if [[ -n "$ROLLBACK_CSV" ]]; then
        create_rollback_csv "$rollback_file" "$ROLLBACK_CSV"
        log_success "Rollback audit CSV saved to: $ROLLBACK_CSV"
    fi
    
    # Ask for confirmation if not in interactive mode and not dry-run
    if [[ "$INTERACTIVE" != "true" && "$DRY_RUN" != "true" ]]; then
        local image_count
        image_count=$(wc -l < "$rollback_file")
        echo
        read -p "Proceed with rollback of $image_count images? (y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Rollback cancelled."
            rm -f "$rollback_file"
            exit 0
        fi
    fi
    
    # Execute rollback
    if execute_rollback "$rollback_file"; then
        log_success "Rollback completed successfully!"
        rm -f "$rollback_file"
        exit 0
    else
        log_error "Rollback completed with errors."
        rm -f "$rollback_file"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"
